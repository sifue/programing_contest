<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> 
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8"> 
<title>最小ターン数を求める - プログラミングコンテスト勉強会第2回</title>
<script src="http://www.google.com/jsapi"></script>
<script>
	google.load("jquery", "1.6.1");
	google.load("jqueryui", "1.8.13");
</script>
<script type="text/javascript">
$(function(){
	$("#calc").button().click(function(){
		var startTime = new Date();
		// 以下解答
		
		//////// 下準備 ///////////
		// 迷路の情報を入れる地図の２次元配列となるオブジェクト中には地点(point)オブジェクトを入れる map[y][x] x→で+ y↓で+
		var map = []; 
		var getPoint = function(arg1,arg2){ 
				switch (arguments.length) {
						case 1: return map[arg1.y][arg1.x];
						case 2: return map[arg2][arg1]
						default : throw "IlegalArgumentException"
						}
			};
		
		// 各地点を定義するオブジェクト作成メソッド
		var createPoint = function(){
			return {
					type : type,
					optimumTracks : null,
					isWall : function(){ return this.type === 'w'},
					isGoal : function(){ return this.type === 'G'}
					};
		};
		
		// トリム値を改行で配列にして処理してマップ作成へ
		var strs = $.trim($("#map").val()).split("\n"); 
		var limit = {x : strs[0].length - 1, y : strs.length - 1 };
		var start = {x : 0, y : 0}
		for(var i = 0; i < strs.length; i++){
			map[i] = [];
			for(var j = 0; j < strs[i].length; j++){
				var type = strs[i].charAt(j);
				// スタートをセット
				if(type === 'S'){ 
					start.x = j;
					start.y = i;
				}
				// 各地点に入れる地点オブジェクトを格納
				map[i][j] = createPoint();
				// console.log("(" + i + "," + j + "):" + map[i][j].isGoal());
			}
		}
		
		


		// 現在地フィールドと移動メソッドを定義する現在地オブジェクト作成メソッド
		var createPosition = function(position){
			return { 
				x : position.x,
				y : position.y,
				tracks: position.tracks === undefined ?
						 [] :
						 position.tracks.slice(0), //過去の移動履歴があればコピー
				validate : function(testedX, testedY){
					if(testedX < 0) return false;
					if(testedX > limit.x) return false;
					if(testedY < 0) return false;
					if(testedY > limit.y) return false;
					if(getPoint(testedX, testedY).isWall()) return false;
					return true;
				},
				move : function(direction){
					var tmpX = this.x;
					var tmpY = this.y;
					
					if(direction == "up"){tmpY　=　tmpY - 1;}
					else if (direction == "down"){tmpY　=　tmpY + 1;}
					else if (direction == "left"){tmpX = tmpX - 1;}
					else if (direction == "right"){tmpX = tmpX + 1;}
					
					var isValid = this.validate(tmpX, tmpY);
					if(isValid){
						this.x = tmpX;
						this.y = tmpY;
					    this.tracks.push(direction); // 移動履歴を追加
					}
					return isValid;
				},
				moveUp : function(){ return this.move("up")},
				moveDown : function(){ return this.move("down")},
				moveLeft : function(){ return this.move("left")},
				moveRight : function(){ return this.move("right")}
			};
		};

		//////// 以下実処理 ///////////
		var moveTypes = ["up", "down", "left", "right"];
		var queue = new Queue();
		queue.enqueue(createPosition(start));
		
		var isReached = false;
		while(!isReached){ // 到着するまでループ
			var tmpQueue = new Queue(); 
			while(!queue.isEmpty()){ // 今回のターンで回すべきqueueでループ
				var preP = queue.dequeue();
				$.each(moveTypes, function(){ // 4方向動作でループ
					var nextP = createPosition(preP);
					if(nextP.move(this)){
						var point = getPoint(nextP);
						// 最適ルートがまだなければ格納
						if(point.optimumTracks == null){point.optimumTracks = nextP.tracks}
					}
				});
			}
			
		}
		
		// 解答終了
		var time = new Date() - startTime;
		if(result){
			$("#answer_area").text("OK(" + time +"ms)");
		}else{
			$("#answer_area").text("NG(" + time +"ms)");
		}
	});
});

/*

Queue.js

A function to represent a queue

Created by Stephen Morley - http://code.stephenmorley.org/ - and released under
the terms of the CC0 1.0 Universal legal code:

http://creativecommons.org/publicdomain/zero/1.0/legalcode

*/
function Queue(){
var _1=[];
var _2=0;
this.getLength=function(){
return (_1.length-_2);
};
this.isEmpty=function(){
return (_1.length==0);
};
this.enqueue=function(_3){
_1.push(_3);
};
this.dequeue=function(){
if(_1.length==0){
return undefined;
}
var _4=_1[_2];
if(++_2*2>=_1.length){
_1=_1.slice(_2);
_2=0;
}
return _4;
};
this.peek=function(){
return (_1.length>0?_1[_2]:undefined);
};
};
</script>
</head>
<h1>迷路の最短路（P02）</h1>
<textarea id="map" cols=40 rows=4>
wS..ww..w.
ww...w..w.
...w......
......www.
....w...w.
....www.w.
..www...w.
....w.....
www.w..ww.
....w..Gw.
</textarea>
<br>
<button id="calc" >Calc!</button>
<br>
答えは: <span id="answer_area"></span>
<br>
<div><a href="http://d.hatena.ne.jp/sifue">吉村 総一郎</a></div><br>
</body>
</html>